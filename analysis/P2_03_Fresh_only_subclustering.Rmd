---
title: "Fresh samples only"
author: "Dominique Paul"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

suppressPackageStartupMessages({
  library(hrbrthemes)
  library(openxlsx)
  library(scater)
  library(scran)
  library(ggplotify)
  library(pheatmap)
  library(BiocParallel)
  library(ggrepel)
  library(ggplot2)
  require(plyr)
  library(dplyr)
  library(viridis)
  library(RhpcBLASctl)
  library(kableExtra)
  library(parallel)
  library(pheatmap)
})


n_workers <- min(detectCores()-1, 16)
RhpcBLASctl::blas_set_num_threads(n_workers)
bpparam <- BiocParallel::MulticoreParam(workers=n_workers, RNGseed = 123)

source("../code/general_purpose_code.R")
```

# Load data for fresh samples combined

In this analysis we focus on subclustering the data for the combined two samples of the "new" protocol as well as the SSc controls.

```{r load data}
sce_fresh <- readRDS("../data/EOS_files/Fresh_EOS2_sce.rds")
```

After manual examination of the clusters above and their respective marker genes we have created a table mapping the unsupervised clusters to their cell type group.

```{r load csv with cluster annotations}
cluster_annotation_mapping <- read.xlsx("../metadata/cluster_annotation_map.xlsx", sheet="Fresh_mixed")
kableExtra::kable(cluster_annotation_mapping)

sce_fresh$manual_labels_coarse <- mapvalues(sce_fresh$label, cluster_annotation_mapping$Cluster.ID, cluster_annotation_mapping$Annotation)
```


```{r heatmap and subcluster labels}
heatmap_marker_genes <- read.xlsx("../metadata/marker_genes_heatmaps.xlsx", sheet="Fresh only - High level")
subclustering_labels <- read.xlsx("../metadata/marker_genes_heatmaps.xlsx", sheet="Fresh only - subclusters")
```

# Manual labelling of Melanocytes and Schwann cells

```{r}
umap_values <- reducedDim(sce_fresh, "UMAP")
mask_location <- as.vector((4 < umap_values[,1]) & (umap_values[,1] < 6) & (6 < umap_values[,2]) & (umap_values[,2] < 8))

mask_melanocytes <- as.vector(mask_location & logcounts(sce_fresh)["PMEL",] > 3)
mask_schwann_cells <- as.vector(mask_location & logcounts(sce_fresh)["PMEL",] < 3)

new_values <- as.vector(sce_fresh$manual_labels_coarse)
new_values[mask_melanocytes] <- "Melanocytes"
new_values[mask_schwann_cells] <- "Schwann cells"
sce_fresh$manual_labels_coarse <- factor(new_values)
```


# UMAPs coloured by cluster and cell type group {.tabset}

We take a look at the UMAPs to check that the mapping is indeed as we expect.

```{r visualise UMAPs, fig.width=16, fig.height=10, results="asis"}
cat("\n\n## Clusters \n\n")
fig3a1 <- plotReducedDim(sce_fresh, "UMAP", colour_by="label", text_by="label", point_size=0.25) +
  labs(title="Unsupervised cluster labels",
       subtitle = "UMAP of fresh samples combined") +
  theme_ipsum_rc() +
  scale_colour_discrete(name = "Cluster labels") +
  theme(#legend.position="bottom",
        panel.spacing = unit(5, "mm")) +
  guides(color=guide_legend(title="",
                            #nrow=1,
                            byrow=TRUE, 
                            override.aes = list(size=4, shape = 15, alpha = 1)))
fig3a1

cat("\n\n## Cell type groups \n\n")
fig3a2 <- plotReducedDim(sce_fresh, "UMAP", colour_by="manual_labels_coarse", text_by="manual_labels_coarse", point_size=0.25) +
  labs(title="Manual labels for high-level clusters",
       subtitle = "UMAP of fresh samples combined") +
  theme_ipsum_rc() +
  get_cell_colours(levels(sce_fresh$manual_labels_coarse)) +
  theme(#legend.position="bottom",
        panel.spacing = unit(5, "mm")) +
  guides(color=guide_legend(title="",
                            # nrow=1,
                            byrow=TRUE, 
                            override.aes = list(size=4, shape = 15, alpha = 1)))
fig3a2
```



# Absolute cell abundance {.tabset}

```{r absolute cell abundance, results="asis", fig.width=12, fig.height=8}
# Samples combined
cat(paste0("\n\n##", " Samples combined \n\n"))
as.data.frame(colData(sce_fresh)) %>%
  dplyr::group_by(manual_labels_coarse) %>%
  dplyr::summarise(counts=n()) %>%
  ggplot(aes(x=manual_labels_coarse, y=counts, fill=manual_labels_coarse)) +
   geom_bar(colour="black", stat="identity") +
   theme_ipsum_rc() +
   labs(title="Annotated cell type counts",
        subtitle="For both samples combined",
        x="", y="Number of cells") +
   theme(axis.text.x=element_text(angle=50, hjust=1),) +
  guides(fill=guide_legend(title="Cell type"))
 
# Sample 1
cat(paste0("\n\n##", " Sample 1 \n\n"))
as.data.frame(colData(sce_fresh)) %>%
  filter(Sample=="Fresh_S1") %>%
  dplyr::group_by(manual_labels_coarse, Sample) %>%
  dplyr::summarise(counts=n()) %>%
  ggplot(aes(x=manual_labels_coarse, y=counts, fill=manual_labels_coarse)) +
   geom_bar(colour="black", stat="identity") +
   theme_ipsum_rc() +
   labs(title="Annotated cell type counts",
        subtitle="For Sample 1",
        x="", y="Number of cells") +
   theme(axis.text.x=element_text(angle=50, hjust=1),) +
  guides(fill=guide_legend(title="Cell type"))

# Sample 2
cat(paste0("\n\n##", " Sample 2 \n\n"))
as.data.frame(colData(sce_fresh)) %>%
  filter(Sample=="Fresh_S2") %>%
  dplyr::group_by(manual_labels_coarse, Sample) %>%
  dplyr::summarise(counts=n()) %>%
  ggplot(aes(x=manual_labels_coarse, y=counts, fill=manual_labels_coarse)) +
   geom_bar(colour="black", stat="identity") +
   theme_ipsum_rc() +
   labs(title="Annotated cell type counts",
        subtitle="For Sample 2",
        x="", y="Number of cells") +
   theme(axis.text.x=element_text(angle=50, hjust=1),) +
  guides(fill=guide_legend(title="Cell type"))
```


# One cell count plot

```{r combined plot, fig.width=12, fig.height=8}
comb <- as.data.frame(colData(sce_fresh)) %>%
  dplyr::group_by(manual_labels_coarse) %>%
  dplyr::summarise(counts=n()) %>%
  mutate(Sample="Combined") %>%
  select(manual_labels_coarse, Sample, counts)

d1 <- as.data.frame(colData(sce_fresh)) %>%
  filter(Sample=="Fresh_S1") %>%
  dplyr::group_by(manual_labels_coarse, Sample) %>%
  dplyr::summarise(counts=n())

d2 <- as.data.frame(colData(sce_fresh)) %>%
  filter(Sample=="Fresh_S2") %>%
  dplyr::group_by(manual_labels_coarse, Sample) %>%
  dplyr::summarise(counts=n())

fig5a <- rbind(comb, d1, d2) %>%
  ggplot(aes(x=manual_labels_coarse, y=counts, fill=manual_labels_coarse)) +
   geom_bar(colour="black", stat="identity") +
   theme_ipsum_rc() +
   labs(title="Annotated cell type counts",
        x="", y="Number of cells") +
   theme(axis.text.x=element_text(angle=50, hjust=1),) +
  facet_wrap(~Sample) +
  get_cell_colours(levels(sce_fresh$manual_labels_coarse), type="fill")

fig5a
```


# Relative cell abundance

```{r fig.width=10, fig.height=10}
data_combined <- as.data.frame(colData(sce_fresh)) %>%
  dplyr::group_by(manual_labels_coarse) %>%
  dplyr::summarise(counts=n()) %>%
  mutate(Sample="Samples combined") %>%
  select(manual_labels_coarse, Sample, counts)

data_by_sample <- as.data.frame(colData(sce_fresh)) %>%
  dplyr::group_by(manual_labels_coarse, Sample) %>%
  dplyr::summarise(counts=n())

fig5b <- rbind(data_combined, data_by_sample) %>%
  ggplot(aes(x=Sample, y=counts, fill=manual_labels_coarse)) +
   geom_bar(colour="black", stat="identity", position="fill") +
   scale_y_continuous(labels = scales::percent) +
   theme_ipsum_rc() +
   labs(title="Relative frequency of cell types",
        x="", y="Number of cells") +
   theme(axis.text.x=element_text(angle=50, hjust=1),) +
  get_cell_colours(levels(sce_fresh$manual_labels_coarse), type="fill")

fig5b
```


# Subclustering

```{r second type of labels}
sce_fresh$manual_labels_coarse2 <- sce_fresh$manual_labels_coarse
sce_fresh$manual_labels_coarse2 <- sub("Vascular endothelial", "Endothelial cells", sce_fresh$manual_labels_coarse2)
sce_fresh$manual_labels_coarse2 <- sub("Lymphatic endothelial", "Endothelial cells", sce_fresh$manual_labels_coarse2)
```

We now look at each cell type group individually. We re-cluster the cells and identify the marker genes of said plots.

```{r subclustering}

run_subclustering <- function(sce_object, cell_type, k=50){
  sce_fresh_copy <- sce_object
  sce_subset <- sce_object[,sce_object$manual_labels_coarse2 == cell_type]
  
  # recluster the cells
  if (dim(sce_subset)[2] < (k+1)){
    cat(paste0(cell_type, " did not have a sufficient number of cells to be subclustered. Minimum required is ", k, " and only ", dim(sce_subset)[2], " cells are labelled as ", cell_type))
    
    return(sce_fresh_copy)
  }
  
  set.seed(100)
  snn.graph <- buildSNNGraph(sce_subset, k=k, use.dimred="harmony")
  clusters <- igraph::cluster_walktrap(snn.graph)$membership
  colData(sce_fresh_copy)[sce_fresh_copy$manual_labels_coarse2 == cell_type, "subcluster_id_k50"] <- clusters



  ##### Re-calculate UMAP #####
  set.seed(100)
  sce_subset <- runUMAP(sce_subset, dimred = 'harmony', subset_row=rowData(sce_subset)$is_hvg, min_dist = 0.1)
  umap_for_cell_type <- reducedDim(sce_subset, "UMAP")
  column_name <- paste0("UMAP_", cell_type)

  # copy from another dimension reduction. This is a workaround to set a
  # dimension reduction for only some of the cells
  reducedDim(sce_fresh_copy, column_name) <- reducedDim(sce_fresh_copy, "UMAP")
  # set all values to 0 first
  reducedDim(sce_fresh_copy, column_name)[,c(1,2)] <- NA
  # Set new values
  attr(reducedDim(sce_fresh_copy, column_name), "scaled:center") <- attr(umap_for_cell_type, "scaled:center")
  reducedDim(sce_fresh_copy, column_name)[rownames(umap_for_cell_type),] <- umap_for_cell_type
  
  return(sce_fresh_copy)
}

special_cases <- c("Fibroblasts", "Macrophages/DC", "Endothelial cells")

for (cell_type in unique(sce_fresh$manual_labels_coarse2)){
  if (cell_type %in% special_cases) next
  sce_fresh <- run_subclustering(sce_fresh, cell_type, k=50)
}

sce_fresh <- run_subclustering(sce_fresh, "Fibroblasts", k=52)
sce_fresh <- run_subclustering(sce_fresh, "Macrophages/DC", k=70)
sce_fresh <- run_subclustering(sce_fresh, "Endothelial cells", k=40)

# transform column into factor values
sce_fresh$subcluster_id_k50_long <- factor(paste0(sce_fresh$manual_labels_coarse2, "_", sce_fresh$subcluster_id_k50))
sce_fresh$subcluster_id_k50 <- factor(sce_fresh$subcluster_id_k50)
```


# Plot UMAPs

```{r plot old and new UMAPs, results="asis"}
k <- 51

# We also create a separate column for each of the cell types. We do this to easily analyse the results in iSee
for (cell_type in unique(sce_fresh$manual_labels_coarse2)){
  colData(sce_fresh)[,cell_type] <- colData(sce_fresh)[,"subcluster_id_k50"]
  colData(sce_fresh)[sce_fresh$manual_labels_coarse2 != cell_type, cell_type] <- NA
  colData(sce_fresh)[, cell_type] <- factor(as.numeric(colData(sce_fresh)[, cell_type]))
}

cat("\n\n## Original UMAP dimensions {.tabset} \n\n")

for (cell_type in unique(sce_fresh$manual_labels_coarse2)){

  # create tab for markdown
  cat("\n\n### ", cell_type, "\n\n")
  
  if (dim(sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type])[2] < k){
    cat("Skipped as the cell type ", cell_type, " was too small to subcluster")
    next
  }

  # plot the UMAP of the subcluster
  print(plotReducedDim(sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type], "UMAP",
                 colour_by = "subcluster_id_k50", text_by="subcluster_id_k50") +
          theme_ipsum_rc() +
    labs(title=cell_type,
         subtitle="k=50"))
}

cat("\n\n## Re-calculated UMAPs {.tabset} \n\n")

for (cell_type in unique(sce_fresh$manual_labels_coarse2)){
  if (dim(sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type])[2] < (k+1)){
    cat("Skipped as the cell type ", cell_type, " was too small to subcluster")
    next
  }

  # create tab for markdown
  cat("\n\n### ", cell_type, "\n\n")
  column_name <- paste0("UMAP_", cell_type)

  # plot the UMAP of the subcluster
  print(plotReducedDim(sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type], column_name,
                 colour_by = "subcluster_id_k50", text_by="subcluster_id_k50") +
          theme_ipsum_rc() +
    labs(title=paste0("Recalculated UMAP for ", cell_type),
         subtitle="k=50"))
}
```


# Plot subcluster sizes per cell type {.tabset}

```{r subcluster sizes, fig.width=10, fig.height=7, results="asis"}
# plot bar charts for cell types
for (cell_type in unique(sce_fresh$manual_labels_coarse2)){
  
  cat("\n\n## ", cell_type, "\n\n")
  
  if (dim(sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type])[2] < (k+1)){
    cat("Skipped as the cell type was too small to subcluster")
    next
  }

  sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]

  data_complete <- as.data.frame(colData(sce_subset)) %>%
    dplyr::group_by(subcluster_id_k50) %>%
    dplyr::summarise(n_cells=n()) %>%
    dplyr::mutate(share= round(n_cells/sum(n_cells),3)) %>%
    mutate(Sample="Samples combined") %>%
    select(Sample, subcluster_id_k50, n_cells, share)


  data_stratified <- as.data.frame(colData(sce_subset)) %>%
    dplyr::group_by(Sample, subcluster_id_k50) %>%
    dplyr::summarise(n_cells=n()) %>%
    dplyr::mutate(share= round(n_cells/sum(n_cells),3))

  print(ggplot(rbind(data_complete, data_stratified),
               aes(x=Sample, y=share, fill=subcluster_id_k50)) +
    geom_bar(stat="identity") +
    facet_grid(subcluster_id_k50 ~ .) +
    labs(title=cell_type,
         subtitle="Bars show fraction of cells for given cell type and sample") +
      theme_ipsum_rc() +
    guides(fill=guide_legend(title="Subcluster")))
  
  print(ggplot(rbind(data_complete, data_stratified),
               aes(x=Sample, y=share, fill=subcluster_id_k50)) +
    geom_bar(stat="identity", position="fill") +
    labs(title=cell_type,
         subtitle="Bars show fraction of cells for given cell type and sample") +
      theme_ipsum_rc() +
      guides(fill=guide_legend(title="Subcluster")))
}
```

# {-}

## Marker genes per subcluster

To identify the differentiated cell types within each cluster we analyse the marker genes using three methods (as before):

1. Welch t-test: fast-computed and good statistical properties for large numbers of cells
    1. We test for marker genes that test significant against ANY other cluster
    1. We test for makrer genes that test singnificant against ALL other clusters
2. Wilcoxon test: directly assesses separation between the expression distributions of clusters
3. Entropy and f-stat method


```{r prepare excel, fig.width=10, fig.height=7, results="asis"}
wb <- createWorkbook()
addWorksheet(wb, "Intro")
writeData(wb, "Intro", data.frame("Marker genes for the subclusters of the samples sequenced with the fresh protocol"),
          colNames=F)

# prepare a theme for adjusting the pheatmap plot
reduced_ipsum_rc_theme <- theme_ipsum_rc() +
  theme(axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank(),
            axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank(),
            panel.grid.major = element_blank(), panel.grid.minor = element_blank())

# We will run three t-tests with very similar function calls.
# We thus define the workflow as a function, allowing the changes to be made via parameter changes
run_marker_gene_analysis <- function(test_name, type_comparison, worksheet_prefix, tabset="###"){

  prefix <- ifelse(test_name=="t", "logFC", "AUC")
  heatmap_lower_limit <- ifelse(test_name=="t", -3, 0)
  heatmap_upper_limit <- ifelse(test_name=="t", 3, 1)

  marker_results_per_cell_type <- list()

  for (cell_type in unique(sce_fresh$manual_labels_coarse2)){
    cat(cell_type)
    # create tab for markdown
    cat(paste0("\n\n", tabset, " ", cell_type, " {.tabset} \n\n"))
    # create the subset
    sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]
    sce_subset$subcluster_id_k50 <- factor(sce_subset$subcluster_id_k50)
    
    if (dim(sce_subset[,sce_subset$manual_labels_coarse2 == cell_type])[2] < 50){
      cat(paste0(cell_type, " was skipped."))
      next
    }

    # get the marker genes for each cluster
    all.markers <- findMarkers(sce_subset, test.type=test_name,
                               pval.type=type_comparison,
                               groups=sce_subset$subcluster_id_k50,
                               direction="up", block=sce_subset$Sample)

    marker_results_per_cell_type[[cell_type]] <- all.markers

    for (marker_num in names(all.markers)){
      # create tab for markdown
      cat(paste0("\n\n#", tabset, " Cluster ", marker_num, " \n\n"))

      # subset marker genes object for a given cluster
      all_cluster_markers <- all.markers[[marker_num]]
      # we only look at union of the top 5 markers per pairwise comparison
      if (type_comparison=="any"){
        cluster_markers <- all_cluster_markers[all_cluster_markers$Top <= 5,]  
      } else {
        cluster_markers <- all_cluster_markers[1:25,]
      }

      cluster_markers_logFCs <- getMarkerEffects(cluster_markers, prefix = prefix)
      cluster_markers_logFCs[is.na(cluster_markers_logFCs)] <- 0

      # Create pheatmap plot per cluster
      if (dim(cluster_markers_logFCs)[2] == 1){
        print(as.ggplot(pheatmap(cluster_markers_logFCs, breaks=seq(heatmap_lower_limit, heatmap_upper_limit, length.out=101), silent=T,
                                 cluster_cols=FALSE)) +
        labs(title=paste0("Cluster ",marker_num),
             subtitle="Pairwise comparisons - comparison with only remaining subcluster") +
        reduced_ipsum_rc_theme)
      } else {
        print(as.ggplot(pheatmap(cluster_markers_logFCs, breaks=seq(heatmap_lower_limit, heatmap_upper_limit, length.out=101), silent=T, cluster_cols=FALSE)) +
                labs(title=paste0("Cluster ", marker_num), subtitle="Pairwise comparisons") +
                reduced_ipsum_rc_theme)
      }

      # write to excel
      cell_type_short <- ifelse(nchar(cell_type) > 10, substr(cell_type, 1, 10), cell_type)
      sheet_name <- paste0("F_", worksheet_prefix, "_", cell_type_short,"_c", marker_num)
      addWorksheet(wb, sheet_name)
      cluster_markers_excel_out <- cbind("Gene"=rownames(all_cluster_markers), all_cluster_markers)
      writeData(wb, sheet_name, cluster_markers_excel_out, rowNames = TRUE)
    }
  }
  return(marker_results_per_cell_type)
}


# Function to plot UMAPs of subclusters for top n genes
plot_umap_feature_plots <- function(markers, n=10, tabset="###"){
  for (cell_type in names(markers)){
    subset_sce <- sce_fresh[, sce_fresh$manual_labels_coarse2 == cell_type]
    cat(paste0("\n\n", tabset, " ", cell_type, "  {.tabset} \n\n"))

    for (marker_num in names(markers[[cell_type]])){
      # set tabs
      cat(paste0("\n\n#", tabset, " Cluster ", marker_num, " {.tabset} \n\n"))
      all_genes <- rownames(markers[[cell_type]][[marker_num]])

      for (i in 1:n){
        gene_name <- all_genes[[i]]
        cat(paste0("\n\n##", tabset, " ", gene_name , " \n\n"))
        x_mu <- mean(reducedDim(subset_sce, "UMAP")[,1])
        x_var <- var(reducedDim(subset_sce, "UMAP")[,1])
        y_mu <- mean(reducedDim(subset_sce, "UMAP")[,2])
        y_var <- var(reducedDim(subset_sce, "UMAP")[,2])

        print(plotReducedDim(subset_sce, dimred="UMAP", colour_by=gene_name, point_size=0.5) +
                labs(title=gene_name, subtitle=paste0(cell_type, " - Marker gene number ", i, "of subcluster ", marker_num)) +
                xlim(x_mu-2*x_var, x_mu+x_var*2) +
                ylim(y_mu-2*y_var, y_mu+y_var*2) +
                theme_ipsum_rc())
      }
    }
  }
}
```

### t-test testing for significance against any other cluster {.tabset}

Testing with the comparison type "any" we select marker genes which are significant in ANY comparison with another cluster. If we should have overclustered and the same cell type is split into two clusters, then marker genes of this cell type would not show up if we would be using the "all" comparison method. The marker genes which define the cell type split into two clusters would show as significant in all comparisons, except the two sister-clusters, and woud thus not show.

```{r t-test any, results="asis"}
all_markers_ttest_any <- run_marker_gene_analysis(test_name = "t", type_comparison = "any", worksheet_prefix = "ttest_any", tabset="####")
```

## UMAPs for each cell type coloured by expression values for top marker genes {.tabset}

We visualise the re-calculated UMAPs for each cluster and colour the cells by the expression values (logscale) of the top marker genes of each subclusters

```{r feature plots, fig.width=10, fig.height=7, results="asis", warnings=FALSE}
plot_umap_feature_plots(all_markers_ttest_any, n=5, tabset="###")
```

## {-}

### t-test testing for significance against all other clusters {.tabset}

While the "all" comparison method has some disadvantages as stated above, can be highly effective when it does work. The method only reports a small set of markers that are highly specific to the cluster of interest.

```{r t-test all, results="asis"}
run_marker_gene_analysis(test_name = "t", type_comparison = "all", worksheet_prefix = "ttest_all", tabset="####")
```

### Wilcoxon {.tabset}

The wilcox directly measures the difference of the expression value distributions of two clusters. It tells us how strong the overlap between the gene expression values for two clusters is. It thus directly measures what we are interested in: the separation of two clusters. The resulting value is proportional to the area-under-the-curve and can be understood as the probability of a random cell in the focus cluster having a higher expression value than the clusters being compared to. 0 means that the expression values of a cell in the cluster are strictly lower than any cell in the other cluster. 1 means that the value of any cell in the cluster is higher than any cell in the cluster it is being compared to. While this test allows us to examine the 'clarity' of separation, the t-test shows us the size of this difference.


```{r wilcox any, results="asis"}
run_marker_gene_analysis(test_name = "wilcox", type_comparison = "any", worksheet_prefix = "wilcox_any", tabset="####")
```


### Entropy f-stat method {.tabset}

```{r fstat-entropy-method, results="asis", fig.width=16, fig.height=10, eval=F}
# define the entropy function which we will apply to our SCE object on a per gene  basis
shannon_entropy <- function(x, e=1e-10){
  x <- x+e
  p <- (x)/sum(x)
  -sum((p)*log(p))
}

# Calculating the entropy and f-statistics takes very long. We split the calculation
# and printing of the results into two parts as there were issues with duplicates
# during printing and this made debugging easier

fstats <- lapply(unique(sce_fresh$manual_labels_coarse2), function(cell_type){
  # cat(paste0("\n\n#### ", cell_type, " {.tabset} \n\n"))

  # create the subset
  sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]
  sce_subset$subcluster_id_k50 <- factor(sce_subset$subcluster_id_k50)

  aggr_sce <- aggregateAcrossCells(sce_subset, sce_subset$subcluster_id_k50)

  # We compute the datarframe containing:
  # (1) the gene name as symbol
  # (2) the entropy of the expression values for a given gene and
  # (3) the f-statistic of the analysis of variance test of the log-experession values vs. the subclusters
  entropy_fstat_sce <- BiocParallel::bplapply(
    seq_along(rownames(aggr_sce)),
    function(.x){
      data.frame(
        gene=rowData(sce_subset)$Symbol[.x],
        entropy=shannon_entropy(counts(aggr_sce[.x,])),
        fstat=summary(aov(logcounts(sce_subset)[.x,]~sce_subset$subcluster_id_k50))[[1]]$`F value`[1]
      )},
    BPPARAM=BiocParallel::MulticoreParam(workers=n_workers, RNGseed = 123)) %>%
      purrr::reduce(rbind)

  # We compare the normalised values of the f-statistic and the entropy.
  entropy_fstat_sce <-  entropy_fstat_sce %>%
    dplyr::mutate(entropy_norm = (entropy + 1e3) / max(entropy + 1e3, na.rm=TRUE),
                  fstat_norm = (fstat + 1e3) / max(fstat + 1e3, na.rm=TRUE),
                  ent_fstat_ratio = fstat_norm / entropy_norm)

})

names(fstats) <- unique(sce_fresh$manual_labels_coarse2)
  
# Show the f-statistic vs the entropy in a plot for all genes
# Also, show violin plots for the top 50 genes

for (cell_type in unique(sce_fresh$manual_labels_coarse2)){
  # Create a tab for the markdown view in workflowr
  cat(paste0("\n\n#### ", cell_type, " {.tabset} \n\n"))
     
  entropy_fstat_sce <- fstats[[cell_type]]
  
  # we select the top 50 markers as defined via the fstat_norm / entropy_norm metric
  topmarkers_order <- order(entropy_fstat_sce$ent_fstat_ratio, decreasing=TRUE)
  topmarkers <- unique(entropy_fstat_sce[topmarkers_order[1:50],])

  # Save the values to our excel
  cell_type_short <- ifelse(nchar(cell_type) > 10, substr(cell_type, 1, 10), cell_type)
  sheet_name <- paste0("F_entropy_", cell_type_short)
  addWorksheet(wb, sheet_name)
  writeData(wb, sheet_name, entropy_fstat_sce[topmarkers_order,], rowNames = TRUE)

  # Plot the f-statistic against the entropy
  cat("\n\n##### Entropy plot \n\n")
  print(ggplot(entropy_fstat_sce) +
    geom_point(aes(x=log(fstat), y=entropy), show.legend = F, colour="#02C39A") +
    labs(x="log(F-statistic)", y="Entropy", title="Entropy vs. F-statistic of cluster separation") +
    ggrepel::geom_text_repel(data=topmarkers,
                             aes(x=log(fstat), y=entropy, label=gene, size=4),
                             show.legend=F,
                             max.overlaps = 30))
}
  
```

### Violin plots for genes in f-stat method {.tabset}

```{r violin plots for genes in f-stat method, fig.width=16, fig.height=10, eval=F}

# Violin plots by cell type
for (cell_type in unique(sce_fresh$manual_labels_coarse2)){
  # Create a tab for the markdown view in workflowr
  cat(paste0("\n\n#### ", cell_type, " {.tabset} \n\n"))
     
  entropy_fstat_sce <- fstats[[cell_type]]
  
  # we select the top 50 markers as defined via the fstat_norm / entropy_norm metric
  topmarkers_order <- order(entropy_fstat_sce$ent_fstat_ratio, decreasing=TRUE)
  topmarkers <- unique(entropy_fstat_sce[topmarkers_order[1:50],])
  entropy_fstat_sce

  # Plot violin plots with the subclusters on the x-axis and the expression values per cell on the y-axis
  # We do this for the top 50 genes as identified by the fstat_norm / entropy_norm metric
  genes_to_plot <-  unique(entropy_fstat_sce$gene[topmarkers_order[1:50]])
  rownames(sce_subset) <- rowData(sce_subset)$Symbol
  
  # If we change from ensemble_gene_id to gene_symbol there are some duplicates.
  # We remove them to avoid errors with the plotting function
  sce_subset <- sce_subset[unique(rownames(sce_subset)),]
  entropy_fstat_sce <- entropy_fstat_sce[!duplicated(entropy_fstat_sce$gene),]
  

  for(i in seq_along(genes_to_plot)){
    cat("\n\n##### ", genes_to_plot[i], "\n\n")
    print(plotExpression(sce_subset,  
                   entropy_fstat_sce$gene[entropy_fstat_sce$gene == genes_to_plot[i]],
                   x = "subcluster_id_k50", point_size=0.5))
  }
}
```



# Heatmaps {.tabset}

```{r coarse heatmap, fig.width=7, fig.height=8, results="asis"}
genes <- heatmap_marker_genes %>%
    pull(Gene)

# the cells which we want to display, ordered by cell type
column_annotations <- data.frame("cell_name"=rownames(colData(sce_fresh)), "Cell_type"=factor(colData(sce_fresh)[,"manual_labels_coarse"])) %>%
    filter(Cell_type!="NA") %>%
    arrange(Cell_type) %>%
    tibble::column_to_rownames(var="cell_name")

# the logcounts which we need for the pheatmap function
sce_plot <- logcounts(sce_fresh[genes, rownames(column_annotations)])

# Use own colours for the column annotations
colours <- get_cell_colours(unique(heatmap_marker_genes$Group), type="raw")
annotation_colours <- list("Cell_type"=colours)


# create the plot. We convert to ggplot to take advantage of some of the display functions
fig4 <- as.ggplot(pheatmap(sce_plot, annotation_col=column_annotations, annotation_colors=annotation_colours,
         show_rownames=TRUE, show_colnames=FALSE, cluster_cols=FALSE, cluster_rows = FALSE, silent=TRUE,
         color=viridis(50))) +
  theme_ipsum_rc() +
  theme(axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(), 
        legend.position="none",
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank()) +
  labs(title="Selected marker genes for cell types")
fig4
```


# Feature plots

```{r figure 3, fig.width=20, fig.height=13}
# Convert the dataframe with marker genes to a list with the cell type as name
unique_cell_types <- unique(heatmap_marker_genes$Group)
genes_list <- lapply(unique_cell_types, function(group){
  heatmap_marker_genes[heatmap_marker_genes$Group==group, "Gene"]
})
names(genes_list) <- unique_cell_types

# write a function to get the average of the logcounts of each gene
get_coloured_expression_plot <- function(gene_list, cell_type){
  sce_tmp <- sce_fresh
  if (length(gene_list) == 1){
    average_values <- logcounts(sce_tmp[gene_list])
  } else {
    average_values <- colMeans(logcounts(sce_tmp[gene_list])) 
  }
  colData(sce_tmp)[,cell_type] <- as.numeric(average_values)
  plt <- plotReducedDim(sce_tmp, "UMAP", colour_by=cell_type, point_size=0.25) +
    labs(title=cell_type,
         subtitle=paste(gene_list, collapse=", ")) +
    theme_ipsum_rc() +
    theme(legend.position="none") +
    theme(plot.margin = margin(t = 0.5,  # Top margin
                               r = 0.5,  # Right margin
                               b = 0.5,  # Bottom margin
                               l = 20)) # Left margin
  plt
 }


plt1 <- get_coloured_expression_plot(genes_list[[1]], names(genes_list)[1])
plt2 <- get_coloured_expression_plot(genes_list[[2]], names(genes_list)[2])
plt3 <- get_coloured_expression_plot(genes_list[[3]], names(genes_list)[3])
plt4 <- get_coloured_expression_plot(genes_list[[4]], names(genes_list)[4])
plt5 <- get_coloured_expression_plot(genes_list[[5]], names(genes_list)[5])
plt6 <- get_coloured_expression_plot(genes_list[[6]], names(genes_list)[6])
plt7 <- get_coloured_expression_plot(genes_list[[7]], names(genes_list)[7])
plt8 <- get_coloured_expression_plot(genes_list[[8]], names(genes_list)[8])
plt9 <- get_coloured_expression_plot(genes_list[[9]], names(genes_list)[9])
plt10 <- get_coloured_expression_plot(genes_list[[10]], names(genes_list)[10])


# store figure as variable and print
fig3b <- gridExtra::grid.arrange(plt1, plt2, plt3, plt4, plt5, plt6, plt7, plt8, plt9, plt10, ncol=4)
fig3b
```


# Papillary v. Reticular fibroblasts

## Average values across all fibroblast cells

```{r, fig.width=14, fig.height=8, warning=F}
papillary_genes <- c("COL18A1", "APCDD1", "HSPB3", "NPTX2", "ROBO2", "COL23A1", "PTGDS", "PDPN", "COL7A1", "COLEC12", "AXIN2") #"CTSC","DCN","INHBB"
reticular_genes <- c("MFAP5", "MGP", "FGF7", "A2M", "ANGPTL1", "IGF1", "EFEMP1", "PCSK5", "MAP1B", "COMP") # "COL14A1, "PPP1R14A", "TAGLN

# subset to a sce object with only the fibroblasts as annotated manually
fibro_sce <- sce_fresh[,colData(sce_fresh)$manual_labels_coarse == "Fibroblasts"]

# are all the genes found in our data?
# papillary_genes %in% rownames(fibro_sce)
# reticular_genes %in% rownames(fibro_sce)
genes <- c(papillary_genes, reticular_genes)

gene_counts <- logcounts(fibro_sce)[genes,]

res <- lapply(unique(fibro_sce$subcluster_id_k50), function(fibro_type){
  mask <- fibro_sce$subcluster_id_k50 == fibro_type
  data.frame("genes"=genes, "rowmeans"=rowMeans(gene_counts[, mask]), "subcluster"=fibro_type)
}) %>% purrr::reduce(rbind)

plt1 <- ggplot(res[res$genes %in% papillary_genes, ], aes(x=genes, y=rowmeans, fill=subcluster)) +
  geom_bar(stat="identity", position="dodge") +
  theme(axis.text.x = element_text(angle = 45,hjust=1), axis.ticks.x=element_blank()) +
  labs(title="Papillary fibroblasts",
       y="Average of logcounts",
       x="")

plt2 <- ggplot(res[res$genes %in% reticular_genes, ], aes(x=genes, y=rowmeans, fill=subcluster)) +
  geom_bar(stat="identity", position="dodge") +
  theme(axis.text.x = element_text(angle = 45,hjust=1), axis.ticks.x=element_blank()) +
  labs(title="Reticular fibroblasts",
       y="Average of logcounts",
       x="")

gridExtra::grid.arrange(plt1, plt2)
```


# Expression values by Fibroblast subcluster

```{r, fig.width=14, fig.height=7, warning=F}
# average of logcounts for papillary fibroblast genes
fibro_sce$papillary_gene_avg <- colMeans(logcounts(fibro_sce)[papillary_genes,])
# average of logcounts for reticular fibroblast genes
fibro_sce$reticular_gene_avg <- colMeans(logcounts(fibro_sce)[reticular_genes,])

plt1 <- plotColData(fibro_sce, x="subcluster_id_k50", y="papillary_gene_avg", colour_by="subcluster_id_k50") +
  labs(title="Papillary Fibroblasts",
       subtitle="Average gene expression for a selection of genes",
       y="",
       x="") +
  ylim(0,3.25) +
  theme_ipsum_rc() +
  theme(legend.position="none")


plt2 <- plotColData(fibro_sce, x="subcluster_id_k50", y="reticular_gene_avg", colour_by="subcluster_id_k50") +
  labs(title="Reticular Fibroblasts",
       subtitle="Average gene expression for a selection of genes",
       y="",
       x="") +
  ylim(0,3.25) +
  theme_ipsum_rc() +
  theme(legend.position="none")

gridExtra::grid.arrange(plt1, plt2, nrow=1)
```

# Supplementary Figures

```{r}
folder_path = "../output/plots/"
```

## Figure 3

```{r figure 3 , fig.width=10, fig.height=12}
figure3 <- suppressMessages(suppressWarnings(ggpubr::ggarrange(
  fig3a2,
  fig3b,
  heights=c(1,1),
  ncol = 1, nrow = 2,labels = "AUTO"
)))


suppressMessages(suppressWarnings((figure3)))

ggsave(paste0(folder_path, "figure3.png"),
       plot=figure3,
       width=20*0.75,
       height=24*0.75,
       units="in",
       bg="white")
```

## Figure 3 supplementary

```{r supplementary figure 3, fig.width=10, fig.height=7}
figure3_supplemental <- fig3a1

ggsave(paste0(folder_path, "figure3_supplemental.png"),
       plot=figure3_supplemental,
       width=14*0.75,
       height=10*0.75,
       units="in",
       bg="white")
```


## Figure 4

```{r supplementary figure 4 , fig.width=7, fig.height=8, warnings=F}
figure4 <- suppressMessages(suppressWarnings(ggpubr::ggarrange(
  fig4,
  heights=c(1),
  ncol = 1, nrow = 1, labels = NULL
)))

suppressMessages(suppressWarnings((figure4)))

ggsave(paste0(folder_path, "figure4.png"),
       plot=figure4,
       width=8*0.75,
       height=7*0.75,
       units="in",
       bg="white")
```

## Figure 5

```{r supplementary figure 5, fig.width=20, fig.height=24, warnings=F}
figure5 <- suppressMessages(suppressWarnings(ggpubr::ggarrange(
  fig5a,
  fig5b,
  heights=c(1,1),
  ncol = 1, nrow = 2, labels = "AUTO"
)))

suppressMessages(suppressWarnings(figure5))

ggsave(paste0(folder_path, "figure5.png"),
       plot=figure5,
       width=20*0.75,
       height=24*0.75,
       units="in",
       bg="white")
```

## Figure 6

```{r add subcluster labels}
sce_fresh$subcluster_names <- NA

for (cell_type in unique(subclustering_labels$Cell.type)){
  # if the cell type was not found in the excel, then its skipped
  if (cell_type %in% sce_fresh$manual_labels_coarse2 == FALSE) {
    cat(paste0(cell_type, " not found in subclustering mapping"))
    next
  }

  sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]
  subset_subcluster_annot <- subclustering_labels[subclustering_labels$Cell.type == cell_type, ] %>%
    select(Cluster, Label) %>%
    distinct()
  
  subcluster_labels <- as.vector(sce_subset$subcluster_id_k50)
  
  colData(sce_fresh)[sce_fresh$manual_labels_coarse2 == cell_type, "subcluster_names"] <- mapvalues(subcluster_labels, subset_subcluster_annot$Cluster, subset_subcluster_annot$Label)
  
}

# unique(subclustering_labels$Cell.type)
# unique(colData(sce_fresh)[sce_fresh$manual_labels_coarse2 == "Fibroblasts", "subcluster_names"])
```

```{r supplementary figure 6, fig.width=20, fig.height=24, warnings=F}
cell_types_fig6 <- c("Fibroblasts", "Endothelial cells", "Keratinocytes", "Pericytes/VSMC", "Macrophages/DC")

get_annotated_subcluster <- function(cell_type){
  sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]
  
  plt <- plotReducedDim(sce_subset, "UMAP",
                 colour_by = "subcluster_names", text_by="subcluster_names") +
    theme_ipsum_rc() +
    labs(title=cell_type) +
    # guides(colour=guide_legend(title="Subcluster")) +
    get_unnamed_colours(unique(sce_subset$subcluster_names), "Subcluster", type="colour") + 
    theme(legend.position="none",
          plot.margin = margin(t = 0.5,  # Top margin
                               r = 0.5,  # Right margin
                               b = 0.5,  # Bottom margin
                               l = 20)) # Left margin 
  plt
}

get_stratified_barplot <- function(cell_type){
   sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]

  data_complete <- as.data.frame(colData(sce_subset)) %>%
    dplyr::group_by(subcluster_names) %>%
    dplyr::summarise(n_cells=n()) %>%
    dplyr::mutate(share= round(n_cells/sum(n_cells),3)) %>%
    mutate(Sample="Samples combined") %>%
    select(Sample, subcluster_names, n_cells, share)

  data_stratified <- as.data.frame(colData(sce_subset)) %>%
    dplyr::group_by(Sample, subcluster_names) %>%
    dplyr::summarise(n_cells=n()) %>%
    dplyr::mutate(share= round(n_cells/sum(n_cells),3))
  
  plt <- ggplot(rbind(data_complete, data_stratified),
               aes(x=Sample, y=share, fill=subcluster_names)) +
    geom_bar(stat="identity") +
    facet_grid(subcluster_names ~ .) +
    labs(title=cell_type,
         subtitle="Bars show fraction of cells for given cell type and sample",
         y="") +
    theme_ipsum_rc() +
    theme(strip.text.y=element_blank()) +
    # guides(fill=guide_legend(title="Subcluster")) +
    get_unnamed_colours(unique(sce_subset$subcluster_names), "Subcluster", type="fill") + 
    scale_y_continuous(labels = scales::percent, n.breaks=3) +
    theme(panel.spacing = unit(2, "mm"),
          # legend.key = element_rect(size=5),
          legend.key.size = unit(2, "lines"),
          plot.margin = margin(t = 0.5,  # Top margin
                               r = 0.5,  # Right margin
                               b = 0.5,  # Bottom margin
                               l = 20)) # Left margin
  plt
}


# UMAPs
fig6a1 <- get_annotated_subcluster(cell_types_fig6[1]) +
  ylim(c(3,7))
fig6b1 <- get_annotated_subcluster(cell_types_fig6[2]) +
  xlim(c(9,16))
fig6c1 <- get_annotated_subcluster(cell_types_fig6[3]) +
  xlim(c(-11,-7)) +
  ylim(c(-5,1))
fig6d1 <- get_annotated_subcluster(cell_types_fig6[4]) +
  xlim(c(-7,-3)) +
  ylim(c(12.5,15.5))
fig6e1 <- get_annotated_subcluster(cell_types_fig6[5])

# barcharts
fig6a2 <- get_stratified_barplot(cell_types_fig6[1])
fig6b2 <- get_stratified_barplot(cell_types_fig6[2])
fig6c2 <- get_stratified_barplot(cell_types_fig6[3])
fig6d2 <- get_stratified_barplot(cell_types_fig6[4])
fig6e2 <- get_stratified_barplot(cell_types_fig6[5])

figure6 <- suppressMessages(suppressWarnings(ggpubr::ggarrange(
  ggpubr::ggarrange(fig6a1, fig6a2, ncol = 2),
  ggpubr::ggarrange(fig6b1, fig6b2, ncol = 2),
  ggpubr::ggarrange(fig6c1, fig6c2, ncol = 2),
  ggpubr::ggarrange(fig6d1, fig6d2, ncol = 2),
  ggpubr::ggarrange(fig6e1, fig6e2, ncol = 2),
  ncol = 1, nrow = 5,labels = "AUTO"
)))

suppressMessages(suppressWarnings(figure6))

ggsave(paste0(folder_path, "figure6.png"),
       plot=figure6,
       width=20*0.9,
       height=24*0.9,
       units="in",
       bg="white")
```


## Figure 7 - Subcluster heatmaps

```{r read heatmap genes}
# sort subclustering_labels alphabetically by the names
heatmap_marker_genes_subclusters <- subclustering_labels %>% 
  arrange(Label)
```

```{r subcluster heatmaps, fig.width=20, fig.height=24, results="asis"}
folder_path <- "/Users/dominiquepaul/xRobinson Group/01_Systemic Sclerosis/output/plots/"

plot_heatmap <- function(cell_type){
  
  sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]
  
  # the genes which we want to display
  genes <- heatmap_marker_genes_subclusters %>%
    filter(Cell.type==cell_type) %>%
    pull(Gene)
  
  # check whether genes are in rownames
  genes_not_found <- genes[genes %in% rownames(sce_subset) == FALSE]
  if (length(genes_not_found) > 0) cat(paste0("\nGenes not found for cell type ", cell_type, ": ", genes_not_found))
  
  genes <- genes[genes %in% rownames(sce_subset)] 
  
  # the cells which we want to display, ordered by subcluster
  column_annotations <- data.frame(row.names=colnames(sce_subset), "Subcluster"=sce_subset$subcluster_names) %>%
    arrange(Subcluster)
  
  # the logcounts which we need for the pheatmap function
  sce_plot <- logcounts(sce_subset[genes, rownames(column_annotations)])
  
  # Use own colours for the column annotations
  colours <- get_unnamed_colours(unique(column_annotations$Subcluster), type="raw")
  annotation_colours <- list("Subcluster"=colours)

  #plt <- grid.grabExpr(draw(hmap, annotation_legend_side="bottom", heatmap_legend_side="right")) +
  plt <- as.ggplot(pheatmap::pheatmap(as.matrix(sce_plot), cluster_cols=FALSE, cluster_rows = FALSE, 
                  show_rownames=TRUE, show_colnames=FALSE, color=viridis(50), 
                  annotation_col=column_annotations, annotation_colors=annotation_colours)) +
    theme_ipsum_rc()+ 
    theme(axis.line=element_blank(),axis.text.x=element_blank(),
            axis.text.y=element_blank(),axis.ticks=element_blank(),
            axis.title.x=element_blank(),
            axis.title.y=element_blank(),legend.position="none",
            panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
            panel.grid.minor=element_blank(),plot.background=element_blank()) +
    labs(title=paste0("Selected subcluster marker genes for ", cell_type))
  
  return(plt)
}

subcluster_heatmap_cell_types <- unique(subclustering_labels$Cell.type)

fig7a <- plot_heatmap(subcluster_heatmap_cell_types[1])
fig7b <- plot_heatmap(subcluster_heatmap_cell_types[2])
fig7c <- plot_heatmap(subcluster_heatmap_cell_types[3])
fig7d <- plot_heatmap(subcluster_heatmap_cell_types[4])
fig7e <- plot_heatmap(subcluster_heatmap_cell_types[5])


figure7 <- suppressMessages(suppressWarnings(ggpubr::ggarrange(
  fig7a, 
  fig7b,
  fig7c,
  fig7d,
  fig7e,
  ncol = 1, nrow = 5,labels = "AUTO"
)))

suppressMessages(suppressWarnings(figure7))

ggsave(paste0(folder_path, "figure7.png"),
       plot=figure7,
       width=20*0.9,
       height=24*0.9,
       units="in",
       bg="white")

```

```{r}
sce_subset <- sce_fresh[,sce_fresh$manual_labels_coarse2 == cell_type]
  
# the genes which we want to display
genes <- heatmap_marker_genes_subclusters %>%
  filter(Cell.type==cell_type) %>%
  pull(Gene)

# check whether genes are in rownames
genes_not_found <- genes[genes %in% rownames(sce_subset) == FALSE]
if (length(genes_not_found) > 0) cat(paste0("\nGenes not found for cell type ", cell_type, ": ", genes_not_found))

genes <- genes[genes %in% rownames(sce_subset)] 

# the cells which we want to display, ordered by subcluster
column_annotations <- data.frame(row.names=colnames(sce_subset), "Subcluster"=sce_subset$subcluster_names) %>%
  arrange(Subcluster)

# the logcounts which we need for the pheatmap function
sce_plot <- logcounts(sce_subset[genes, rownames(column_annotations)])

# Use own colours for the column annotations
colours <- get_unnamed_colours(unique(column_annotations$Subcluster), type="raw")
annotation_colours <- list("Subcluster"=colours)
```


# Save Files

## Save Excel

```{r save excel, class.source="fold-show"}
filename <- "../docs/output/Protocol_subclustering_markers_genes.xlsx"
saveWorkbook(wb, filename, overwrite=TRUE)
```

# Save SCE object

```{r save sce object, class.source="fold-show"}
file_path <- "../data/EOS_files/Fresh_EOS3_sce.rds"
saveRDS(sce_fresh, file=file_path)
upload_file_to_iSEE(file_path)
```


